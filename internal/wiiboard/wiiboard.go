package wiiboard

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/gvalkov/golang-evdev"
	"github.com/pkg/errors"
)

const (
	deviceglob      = "/dev/input/event*"
	nintendoVendor  = 0x057E
	wiiBoardProduct = 0x0306
)

// WiiBoard is the currently connected wiiboard connection
type WiiBoard struct {
	Events      chan Event
	conn        *evdev.InputDevice
	batteryPath string
}

// Event represents various pressure point generated by the wii balance board
type Event struct {
	TopLeft     int32
	TopRight    int32
	BottomRight int32
	BottomLeft  int32
	Button      bool
}

// Detect enables picking first connected WiiBoard on the system
func Detect() (WiiBoard, error) {
	devices, err := evdev.ListInputDevices(deviceglob)
	if err != nil {
		return WiiBoard{}, errors.Wrapf(err, "couldn't list input device on system")
	}

	for _, dev := range devices {
		if dev.Vendor != nintendoVendor || dev.Product != wiiBoardProduct {
			continue
		}

		// look for battery path
		var batteryPath string
		f, err := os.Open("/proc/bus/input/devices")
		if err != nil {
			return WiiBoard{}, errors.Wrapf(err, "couldn't find input device list file")
		}
		defer f.Close()

		boardStenza := false
		matchBoard := fmt.Sprintf("Vendor=0%x Product=0%x", nintendoVendor, wiiBoardProduct)
		re := regexp.MustCompile("S: Sysfs=(.*)")
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			t := scanner.Text()
			if t == "" && boardStenza {
				return WiiBoard{}, errors.New("didn't find expected sys location in input device list file")
			}
			if strings.Contains(t, matchBoard) {
				boardStenza = true
			}
			if !boardStenza {
				continue
			}
			res := re.FindStringSubmatch(t)
			if len(res) < 2 {
				continue
			}
			m, err := filepath.Glob("/sys" + res[1] + "/device/power_supply/*/capacity")
			if err != nil || len(m) != 1 {
				return WiiBoard{}, errors.New("didn't find expected battery capacity location")
			}
			batteryPath = m[0]
			break
		}
		if err := scanner.Err(); err != nil {
			return WiiBoard{}, errors.Wrapf(err, "error reading input device list file")
		}

		return WiiBoard{
			conn:        dev,
			batteryPath: batteryPath,
			Events:      make(chan Event),
		}, nil
	}

	return WiiBoard{}, errors.New("Didn't find any WiiBoard")
}

// Listen start sending events on Events property of the board
func (w WiiBoard) Listen() {
	curEvent := Event{}
	_ = curEvent
	for {
		events, err := w.conn.Read()
		if err != nil {
			logrus.Info("Error in getting event from device: %v", err)
			continue
		}
		for _, e := range events {
			switch e.Type {

			case evdev.EV_SYN:
				// send current event and reset it
				w.Events <- curEvent
				curEvent = Event{}

			// pressure point
			case evdev.EV_ABS:
				switch e.Code {
				case evdev.ABS_HAT0Y:
					curEvent.BottomRight = e.Value
				case evdev.ABS_HAT1Y:
					curEvent.BottomLeft = e.Value
				case evdev.ABS_HAT0X:
					curEvent.TopRight = e.Value
				case evdev.ABS_HAT1X:
					curEvent.TopLeft = e.Value
				default:
					if m, exists := evdev.ByEventType[int(e.Type)]; exists {
						logrus.Infof("Unexpected event code: %s", m[int(e.Code)])
					} else {
						logrus.Infof("Unexpected unknown event code: %d", e.Code)
					}
				}

			// main button
			case evdev.EV_KEY:
				if e.Code != 304 {
					logrus.Infof("Unexpected event code: %d", e.Code)
					continue
				}
				curEvent.Button = true
			default:
				logrus.Infof("Unexpected unknown event type: %d", e.Type)
			}
		}
	}
}

// Battery returns current power level
func (w WiiBoard) Battery() (int, error) {
	b, err := ioutil.ReadFile(w.batteryPath)
	if err != nil {
		return 0, errors.Wrap(err, "couldn't read from board battery file")
	}
	battery, err := strconv.Atoi(strings.TrimSpace(string(b)))
	if err != nil {
		return 0, errors.Wrap(err, "didn't find an integer in battery capacity file")
	}
	return battery, nil
}
